import express from 'express';
import cors from 'cors';
import bodyParser from 'body-parser';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';
import dotenv from 'dotenv';
dotenv.config();

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const app = express();
const PORT = process.env.PORT || 3001;
const PROJECTS_DIR = path.resolve(__dirname, '../projects');

app.use(cors());
app.use(bodyParser.json());
fs.ensureDirSync(PROJECTS_DIR);

// Projects CRUD
app.get('/api/projects', async (req, res) => {
  try {
    const items = await fs.readdir(PROJECTS_DIR, { withFileTypes: true });
    const projects = await Promise.all(
      items.filter((d) => d.isDirectory()).map(async (dir) => {
        const pkgPath = path.join(PROJECTS_DIR, dir.name, 'package.json');
        let meta = { description: 'Generated project', type: 'web' };
        if (await fs.pathExists(pkgPath)) {
          try {
            const pkg = await fs.readJson(pkgPath);
            meta = { ...meta, ...(pkg.appforgeMetadata || {}) };
          } catch (_) {}
        }
        return {
          id: dir.name,
          name: dir.name,
          description: meta.description || 'No description',
          type: meta.type || 'web',
          status: 'Ready',
          lastEdited: 'Just now',
          deliverables: meta.deliverables || [],
        };
      })
    );
    res.json(projects);
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

app.post('/api/projects', async (req, res) => {
  const { name, description, type } = req.body;
  const projectPath = path.join(PROJECTS_DIR, name);
  try {
    if (await fs.pathExists(projectPath)) return res.status(400).json({ error: 'Project already exists' });
    await fs.ensureDir(projectPath);
    const deliverables = [
      { type: 'htmlpreview', label: 'Preview', url: '/project-preview/' + encodeURIComponent(name) + '/index.html' },
      { type: 'code', label: 'index.html', file: 'index.html' },
      { type: 'code', label: 'App.jsx', file: 'src/App.jsx' },
      { type: 'code', label: 'main.jsx', file: 'src/main.jsx' },
      { type: 'download', label: 'Package', file: 'package.json' },
    ];
    const packageJson = {
      name: name.toLowerCase().replace(/\s+/g, '-'),
      version: '0.1.0',
      private: true,
      appforgeMetadata: { description, type, deliverables },
      scripts: { dev: 'vite', build: 'vite build' },
      dependencies: { react: '^18.2.0', 'react-dom': '^18.2.0' },
    };
    const indexHtml = `<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>${name}</title>
<style>*{margin:0;padding:0;box-sizing:border-box;}body{font-family:system-ui,sans-serif;min-height:100vh;background:linear-gradient(135deg,#0ea5e9 0%,#d946ef 100%);display:flex;align-items:center;justify-content:center;padding:2rem;}
.card{background:white;padding:3rem;border-radius:1.5rem;box-shadow:0 25px 50px -12px rgba(0,0,0,0.25);max-width:500px;text-align:center;}
h1{font-size:2rem;color:#0f172a;margin-bottom:1rem;}p{color:#64748b;line-height:1.6;}.badge{display:inline-block;background:linear-gradient(135deg,#0ea5e9,#d946ef);color:white;padding:0.5rem 1rem;border-radius:2rem;font-size:0.85rem;font-weight:600;}</style>
</head>
<body><div class="card"><h1>${name}</h1><p>${description || 'Generated by AppForge'}</p><span class="badge">AppForge</span></div></body>
</html>`;
    const appJsx = `import React from 'react';\nexport default function App() {\n  return (\n    <div style={{ fontFamily: 'sans-serif', padding: '2rem' }}>\n      <h1>${name}</h1>\n      <p>${description || 'Generated by AppForge'}</p>\n    </div>\n  );\n}`;
    const mainJsx = `import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\nReactDOM.createRoot(document.getElementById('root')).render(<React.StrictMode><App /></React.StrictMode>);`;
    await fs.writeJson(path.join(projectPath, 'package.json'), packageJson, { spaces: 2 });
    await fs.writeFile(path.join(projectPath, 'index.html'), indexHtml);
    await fs.ensureDir(path.join(projectPath, 'src'));
    await fs.writeFile(path.join(projectPath, 'src', 'App.jsx'), appJsx);
    await fs.writeFile(path.join(projectPath, 'src', 'main.jsx'), mainJsx);
    res.json({ success: true, path: projectPath, deliverables });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

app.get('/api/files', async (req, res) => {
  const { project, file } = req.query;
  if (!project || !file) return res.status(400).json({ error: 'Missing params' });
  const filePath = path.join(PROJECTS_DIR, project, file);
  if (!path.resolve(filePath).startsWith(path.resolve(PROJECTS_DIR))) return res.status(403).json({ error: 'Access denied' });
  try {
    if (await fs.pathExists(filePath)) {
      const content = await fs.readFile(filePath, 'utf-8');
      res.json({ content });
    } else res.status(404).json({ error: 'File not found' });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

app.put('/api/files', async (req, res) => {
  const { project, file, content } = req.body;
  if (!project || !file || content === undefined) return res.status(400).json({ error: 'Missing params' });
  const filePath = path.join(PROJECTS_DIR, project, file);
  if (!path.resolve(filePath).startsWith(path.resolve(PROJECTS_DIR))) return res.status(403).json({ error: 'Access denied' });
  try {
    await fs.ensureDir(path.dirname(filePath));
    await fs.writeFile(filePath, content);
    res.json({ success: true });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

app.use('/project-preview', express.static(PROJECTS_DIR));

app.get('/api/download', async (req, res) => {
  const { project, file } = req.query;
  if (!project || !file) return res.status(400).send('Missing params');
  const filePath = path.join(PROJECTS_DIR, project, file);
  if (!path.resolve(filePath).startsWith(path.resolve(PROJECTS_DIR))) return res.status(403).send('Access denied');
  try {
    if (await fs.pathExists(filePath)) res.download(filePath);
    else res.status(404).send('Not found');
  } catch (e) {
    res.status(500).send(e.message);
  }
});

app.delete('/api/projects/:name', async (req, res) => {
  const projectPath = path.join(PROJECTS_DIR, req.params.name);
  if (!path.resolve(projectPath).startsWith(path.resolve(PROJECTS_DIR))) return res.status(403).json({ error: 'Access denied' });
  try {
    if (await fs.pathExists(projectPath)) {
      await fs.remove(projectPath);
      res.json({ success: true });
    } else res.status(404).json({ error: 'Project not found' });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// AI: optional OpenAI-compatible endpoint (user provides API key in app)
let openaiClient = null;
async function getOpenAI() {
  const apiKey = process.env.OPENAI_API_KEY || process.env.CEREBRAS_API_KEY;
  if (!apiKey) return null;
  if (!openaiClient) {
    const OpenAI = (await import('openai')).default;
    openaiClient = new OpenAI({
      apiKey,
      baseURL: process.env.OPENAI_BASE_URL || 'https://api.openai.com/v1',
    });
  }
  return openaiClient;
}

app.post('/api/ai/chat', async (req, res) => {
  const { message, context } = req.body;
  if (!message) return res.status(400).json({ error: 'Message required' });
  const client = await getOpenAI();
  if (!client) {
    return res.json({
      response: 'Add OPENAI_API_KEY or CEREBRAS_API_KEY in server .env to enable AI. You can still create projects without AI.',
      blocked: false,
    });
  }
  try {
    const completion = await client.chat.completions.create({
      model: process.env.OPENAI_MODEL || 'gpt-4o-mini',
      messages: [
        { role: 'system', content: (context || '') + '\nYou are a helpful coding assistant. Reply briefly.' },
        { role: 'user', content: message },
      ],
      max_tokens: 1024,
    });
    const text = completion.choices[0]?.message?.content || 'No response';
    res.json({ response: text, blocked: false });
  } catch (e) {
    res.status(500).json({ error: e.message, response: 'AI error: ' + e.message });
  }
});

app.get('/api/ai/status', async (req, res) => {
  const configured = !!(process.env.OPENAI_API_KEY || process.env.CEREBRAS_API_KEY);
  res.json({
    configured,
    provider: configured ? (process.env.OPENAI_BASE_URL ? 'Custom' : 'OpenAI') : 'None',
    capabilities: ['chat', 'create-project'],
    ready: configured,
  });
});

app.listen(PORT, () => {
  console.log('AppForge server at http://localhost:' + PORT);
  console.log('Projects:', PROJECTS_DIR);
});
